---
layout: post
title: Using graphs to analyze Windows Firewall logs
date: 2017-08-08 00:53:57.000000000 +03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: '43452'
  _publicize_job_id: '8015292335'
author:
  login: eosfor
  email: eosfor@gmail.com
  display_name: eosfor
  first_name: ''
  last_name: ''
---
<p>Hello colleagues, lets talk about how we can use graphs to look inside of communications happening in our environments in an easy way. First of all we need to have some data to analyze. Lets gather some. It is pretty simple - just use <a href="https://technet.microsoft.com/en-us/library/cc947815(v=ws.10).aspx">this</a> article and enable Windows Firewall Logging. I usually put the logs into a separate folder, just for easy access. Here is how it looks like on my system:</p>
<p><img class="alignnone size-full wp-image-315" src="{{ site.baseurl }}/assets/fwlog.png" alt="FWLog" width="1300" height="301" /></p>
<p>As you can see it is structured, so it is good idea to parse it as objects. Lets do it, and it may look like the following:</p>
<p>[code language="powershell"]<br />
$f = gc 'C:\Logs\FWLogs\pfirewall_public - Copy.log'<br />
$regex = '^(?&lt;datetime&gt;\d{4,4}-\d{2,2}-\d{2,2}\s\d{2}:\d{2}:\d{2})\s(?&lt;action&gt;\w+)\s(?&lt;protocol&gt;\w+)\s(?&lt;srcip&gt;\b(?:\d{1,3}\.){3}\d{1,3}\b)\s(?&lt;dstip&gt;\b(?:\d{1,3}\.){3}\d{1,3}\b)\s(?&lt;srcport&gt;\d{1,5})\s(?&lt;dstport&gt;\d{1,5})\s(?&lt;size&gt;\d+|-)\s(?&lt;tcpflags&gt;\d+|-)\s(?&lt;tcpsyn&gt;\d+|-)\s(?&lt;tcpack&gt;\d+|-)\s(?&lt;tcpwin&gt;\d+|-)\s(?&lt;icmptype&gt;\d+|-)\s(?&lt;icmpcode&gt;\d+|-)\s(?&lt;info&gt;\d+|-)\s(?&lt;path&gt;.+)$'</p>
<p>$log =<br />
$f | % {<br />
    $_ -match $regex | Out-Null<br />
    if ($Matches) {<br />
    [PSCustomObject]@{<br />
        action   = $Matches.action<br />
        srcip    = [ipaddress]$Matches.srcip<br />
        dstport  = $Matches.dstport<br />
        tcpflags = $Matches.tcpflags<br />
        dstip    = [ipaddress]$Matches.dstip<br />
        info     = $Matches.info<br />
        size     = $Matches.size<br />
        protocol = $Matches.protocol<br />
        tcpack   = $Matches.tcpac<br />
        srcport  = $Matches.srcport<br />
        tcpsyn   = $Matches.tcpsyn<br />
        datetime = [datetime]$Matches.datetime<br />
        icmptype = $Matches.icmptype<br />
        tcpwin   = $Matches.tcpwin<br />
        icmpcode = $Matches.icmpcode<br />
        path     = $Matches.path<br />
    }<br />
    }<br />
}<br />
[/code]</p>
<p>The <strong>$regex</strong> variable here contains a long regular expression which hopefully is going to parse our file onto objects - one per line. We use <strong>-match</strong> operator in the pipeline to apply this expression to each line of the file and suppress output by piping it to <strong>Out-Null</strong>. This is not the fastest way of parsing files but to me one of the easiest ones. If the there is a match <strong>$Matches</strong> variable gets populated. Here we want to do the trick. First we fill in the hashtable with the fields we would like to put into our new object and then convert this hashtable to an object. One thing to pay attention to is we convert datetime field into [datetime] type to be able to use filtering and sorting capabilities later on. The same we do with ip addresses. So at the end we've got objects and they look like this:</p>
<p><img class="alignnone size-full wp-image-418" src="{{ site.baseurl }}/assets/fwlog3.png" alt="fwlog3" width="382" height="411" /></p>
<p>Looks great so far, but what is next? First of all objects we've got are just edges of our graph. So what we can do now to convert the set of edges to a set of vertices along with their edges? This is really easy, lets just add them</p>
<p>[code language="powershell"]<br />
$g = new-graph -Type BidirectionalGraph</p>
<p>$log | ? {$_.srcip -and $_.dstip} | % {<br />
    Add-Edge -From $_.srcip -To $_.dstip -Graph $g | out-null<br />
}<br />
[/code]</p>
<p>So here we create a graph and add vertices. Source and destination IPs being converted into string representations and added to the graph, and the library itself takes care about duplicated entries. So at the end we have a $g variable containing the graph. Now we can easily display it by issuing</p>
<p>[code language="powershell"]<br />
Show-GraphLayout -Graph $g<br />
[/code]</p>
<p>which will display something like this<br />
<img class="alignnone size-full wp-image-458" src="{{ site.baseurl }}/assets/fwlog4.png" alt="fwlog4" width="517" height="659" /><br />
It does not look beautiful for me as it basically shows only a single log from my own laptop. But if we had multiple logs from some environment we would be able to see communications happened inside and outside the environment.<br />
What else can we do here? For example we can try to filter the set of log data we parsed and display the smaller subset of data, for instance like this</p>
<p>[code language="powershell"]<br />
$d = ($log | sort datetime -Descending | select -First 1).datetime.addhours(-1)<br />
$twoHrsLog = $log.Where({$_.datetime -gt $d})</p>
<p>$g1 = new-graph -Type BidirectionalGraph</p>
<p>$twoHrsLog | ? {$_.srcip -and $_.dstip} | % {<br />
    Add-Edge -From $_.srcip -To $_.dstip -Graph $g1 | out-null<br />
}<br />
Show-GraphLayout -Graph $g1<br />
[/code]</p>
<p>where we just filter the log to see just communications happened for the last hour. We could also filter by IPs or by degree of out or in edges</p>
<p>[code language="powershell"]<br />
$g2 = new-graph -Type BidirectionalGraph<br />
$x = $g.Vertices.Where({$g.OutDegree($_) -gt 0})</p>
<p>$x | where {$_ -ne '192.168.0.107'} | % {$e = $g.InEdges($_); if ($e) {$e | % {add-edge -from $_.source -to $_.target -Graph $g2}}}<br />
$x | where {$_ -ne '192.168.0.107'} | % {$e = $g.OutEdges($_); if ($e) {$e | % {add-edge -from $_.source -to $_.target -Graph $g2}}}</p>
<p>Show-GraphLayout -Graph $g2<br />
[/code]</p>
<p>Complete set of commands is below</p>
<p>[code language="powershell"]<br />
#file and regular expression<br />
$f = gc 'C:\Logs\FWLogs\pfirewall_public - Copy.log'<br />
$regex = '^(?&lt;datetime&gt;\d{4,4}-\d{2,2}-\d{2,2}\s\d{2}:\d{2}:\d{2})\s(?&lt;action&gt;\w+)\s(?&lt;protocol&gt;\w+)\s(?&lt;srcip&gt;\b(?:\d{1,3}\.){3}\d{1,3}\b)\s(?&lt;dstip&gt;\b(?:\d{1,3}\.){3}\d{1,3}\b)\s(?&lt;srcport&gt;\d{1,5})\s(?&lt;dstport&gt;\d{1,5})\s(?&lt;size&gt;\d+|-)\s(?&lt;tcpflags&gt;\d+|-)\s(?&lt;tcpsyn&gt;\d+|-)\s(?&lt;tcpack&gt;\d+|-)\s(?&lt;tcpwin&gt;\d+|-)\s(?&lt;icmptype&gt;\d+|-)\s(?&lt;icmpcode&gt;\d+|-)\s(?&lt;info&gt;\d+|-)\s(?&lt;path&gt;.+)$'</p>
<p>#parsing<br />
$log =<br />
$f | % {<br />
    $_ -match $regex | Out-Null<br />
    if ($Matches) {<br />
    [PSCustomObject]@{<br />
        action   = $Matches.action<br />
        srcip    = [ipaddress]$Matches.srcip<br />
        dstport  = $Matches.dstport<br />
        tcpflags = $Matches.tcpflags<br />
        dstip    = [ipaddress]$Matches.dstip<br />
        info     = $Matches.info<br />
        size     = $Matches.size<br />
        protocol = $Matches.protocol<br />
        tcpack   = $Matches.tcpac<br />
        srcport  = $Matches.srcport<br />
        tcpsyn   = $Matches.tcpsyn<br />
        datetime = [datetime]$Matches.datetime<br />
        icmptype = $Matches.icmptype<br />
        tcpwin   = $Matches.tcpwin<br />
        icmpcode = $Matches.icmpcode<br />
        path     = $Matches.path<br />
    }<br />
    }<br />
}</p>
<p> #whole graph<br />
$g = new-graph -Type BidirectionalGraph</p>
<p>$log | ? {$_.srcip -and $_.dstip} | % {<br />
    Add-Edge -From $_.srcip -To $_.dstip -Graph $g | out-null<br />
}</p>
<p>Show-GraphLayout -Graph $g</p>
<p>#subset of log records filterd by time<br />
$d = ($log | sort datetime -Descending | select -First 1).datetime.addhours(-1)<br />
$twoHrsLog = $log.Where({$_.datetime -gt $d})</p>
<p>$g1 = new-graph -Type BidirectionalGraph</p>
<p>$twoHrsLog | ? {$_.srcip -and $_.dstip} | % {<br />
    Add-Edge -From $_.srcip -To $_.dstip -Graph $g1 | out-null<br />
}<br />
Show-GraphLayout -Graph $g1</p>
<p>#subset of log records filterd by degree of edges<br />
$g2 = new-graph -Type BidirectionalGraph<br />
$x = $g.Vertices.Where({$g.OutDegree($_) -gt 0})</p>
<p>$x | where {$_ -ne '192.168.0.107'} | % {$e = $g.InEdges($_); if ($e) {$e | % {add-edge -from $_.source -to $_.target -Graph $g2}}}<br />
$x | where {$_ -ne '192.168.0.107'} | % {$e = $g.OutEdges($_); if ($e) {$e | % {add-edge -from $_.source -to $_.target -Graph $g2}}}</p>
<p>Show-GraphLayout -Graph $g2<br />
[/code]</p>
